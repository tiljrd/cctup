CCIP_UI_CONFIG_TEMPLATE = """# Auto-generated CCIP Network Configuration
# Generated by Kurtosis CCIP Package

networks:
{{range .Networks}}
  - id: {{.ChainID}}
    key: "{{.Key}}"
    name: "{{.Name}}"
    nativeCurrency:
      name: "{{.NativeCurrency.Name}}"
      symbol: "{{.NativeCurrency.Symbol}}"
      decimals: {{.NativeCurrency.Decimals}}
    rpcUrls:
      - "{{.RpcUrl}}"
    blockExplorer:
      name: "{{.Explorer.Name}}"
      url: "{{.Explorer.Url}}"
    logoURL: "{{.LogoURL}}"
    testnet: {{.Testnet}}
    chainSelector: "{{.ChainSelector}}"
    linkContract: "{{.LinkContract}}"
    routerAddress: "{{.RouterAddress}}"

{{end}}
tokens:
{{range .Tokens}}
  - symbol: "{{.Symbol}}"
    logoURL: "{{.LogoURL}}"
    tags: {{.Tags}}
    addresses:
      {{range $key, $value := .Addresses}}{{$key}}: "{{$value}}"
      {{end}}
{{end}}"""

def spinup_ccip_ui(plan, contracts_addresses, chains_config):
    """Spins up the CCIP UI with dynamically generated network configuration"""
    
    # Prepare template data
    networks = []
    token_addresses = {"CCIP-BnM": {}, "LINK": {}, "WETH": {}}
    
    for chain in chains_config:
        chain_contracts = contracts_addresses.chains_contracts.get(chain["name"], {})
        
        # Build network
        network = {
            "ChainID": chain["chain_id"],
            "Key": chain["name"],
            "Name": chain.get("display_name", chain["name"].title()),
            "NativeCurrency": {
                "Name": chain.get("native_currency_name", "ETH"),
                "Symbol": chain.get("native_currency_symbol", "ETH"),
                "Decimals": chain.get("native_currency_decimals", 18)
            },
            "RpcUrl": chain["rpc_url"],
            "Explorer": {
                "Name": chain.get("explorer_name", "Explorer"),
                "Url": chain.get("explorer_url", "")
            },
            "LogoURL": _get_chain_logo(chain["name"]),
            "Testnet": True,
            "ChainSelector": chain["chain_selector"],
            "LinkContract": chain_contracts.linkToken or chain["existing_contracts"]["link_token"],
            "RouterAddress": chain_contracts.router
        }
        networks.append(network)
        
        # Collect token addresses
        token_addresses["LINK"][chain["name"]] = network["LinkContract"]
        if "weth9" in chain.get("existing_contracts", {}):
            token_addresses["WETH"][chain["name"]] = chain["existing_contracts"]["weth9"]
    
    # Build tokens
    token_configs = {
        "CCIP-BnM": {"logo": "ccip-bnm", "tags": ["chainlink", "default"]},
        "LINK": {"logo": "link", "tags": ["chainlink", "default"]},
        "WETH": {"logo": "weth", "tags": ["wrapped", "default"]}
    }
    
    tokens = []
    for symbol, addresses in token_addresses.items():
        if addresses:
            config = token_configs[symbol]
            tokens.append({
                "Symbol": symbol,
                "LogoURL": "https://smartcontract.imgix.net/tokens/{}.webp?auto=compress%2Cformat".format(config["logo"]),
                "Tags": json.encode(config["tags"]),
                "Addresses": addresses
            })
    
    # Generate config artifact
    config_artifact = plan.render_templates(
        name = "ccip-ui-config",
        config = {
            "network-config.yaml": struct(
                template = CCIP_UI_CONFIG_TEMPLATE,
                data = {"Networks": networks, "Tokens": tokens}
            )
        }
    )
    
    # Start service
    ccip_ui = plan.add_service(
        name = "ccip-ui",
        config = ServiceConfig(
            image = CCIP_UI_IMAGE,
            ports = {"http": PortSpec(number = 3000, transport_protocol = "TCP")},
            files = {"/app/public": config_artifact},
            env_vars = {"NEXT_PUBLIC_CCIP_CONFIG_FILE": "/network-config.yaml"}
        )
    )
    
    plan.print("CCIP UI started at: http://{}:{}".format(ccip_ui.ip_address, ccip_ui.ports["http"].number))
    return ccip_ui

def _get_chain_logo(chain_name):
    """Returns logo URL for known chains"""
    logos = {"ethereum": "ethereum", "sepolia": "ethereum", "arbitrum": "arbitrum", 
             "optimism": "optimism", "polygon": "polygon", "avalanche": "avalanche", 
             "bsc": "bsc", "base": "base"}
    
    for key, logo in logos.items():
        if key in chain_name.lower():
            return "https://d2f70xi62kby8n.cloudfront.net/bridge/icons/networks/{}.svg?auto=compress%2Cformat".format(logo)
    return "https://d2f70xi62kby8n.cloudfront.net/bridge/icons/networks/ethereum.svg?auto=compress%2Cformat" 